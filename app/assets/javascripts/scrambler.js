// Generated by CoffeeScript 1.10.0
(function() {
  Cubemania.Scrambler = (function() {
    var clock, cube, doMove, doSlice, humanize_sq_one_move, megaminx, possibleMoves, pyraminx, rand, splitLayer, square1;

    function Scrambler() {
      this.mark2 = scramblers;
      this.mark2["222"].initialize(null, Math);
      this.mark2["pyram"].initialize(null, Math);
    }

    Scrambler.prototype.scramble = function(puzzle) {
      switch (puzzle.toLowerCase()) {
        case "2x2x2":
          return this.mark2["222"].getRandomScramble().scramble_string;
        case "3x3x3":
          return cube([["R", "L"], ["F", "B"], ["U", "D"]], 25);
        case "4x4x4":
          return cube([["R", "L", "Rw", "Lw"], ["F", "B", "Fw", "Bw"], ["D", "U", "Dw", "Uw"]], 40);
        case "5x5x5":
          return cube([["R", "L", "Rw", "Lw"], ["F", "B", "Fw", "Bw"], ["D", "U", "Dw", "Uw"]], 60);
        case "6x6x6":
          return cube([["R", "L", "2R", "2L", "3R", "3L"], ["F", "B", "2F", "2B", "3F", "3B"], ["D", "U", "2D", "2U", "3D", "3U"]], 80);
        case "7x7x7":
          return cube([["R", "L", "2R", "2L", "3R", "3L"], ["F", "B", "2F", "2B", "3F", "3B"], ["D", "U", "2D", "2U", "3D", "3U"]], 100);
        case "megaminx":
          return megaminx(7, 10);
        case "pyraminx":
          return this.mark2["pyram"].getRandomScramble().scramble_string;
        case "clock":
          return clock(25);
        case "square-1":
          return square1();
        case "skewb":
          return cube([["U"], ["L"], ["R"], ["B"]], 15, ['', "'"]);
        default:
          return "";
      }
    };

    cube = function(turns, length, variants) {
      var axis, x;
      if (variants == null) {
        variants = ['', "'", '2'];
      }
      axis = rand(turns.length);
      return ((function() {
        var j, ref, results;
        results = [];
        for (x = j = 1, ref = length; 1 <= ref ? j <= ref : j >= ref; x = 1 <= ref ? ++j : --j) {
          results.push((axis = (axis + rand(turns.length - 1) + 1) % turns.length, turns[axis].sample() + variants.sample()));
        }
        return results;
      })()).join(" ");
    };

    megaminx = function(lines, columns) {
      var column, line, row, turns, variants, variantsForU;
      turns = ["R", "D"];
      variants = ["--", "++"];
      variantsForU = ["'", ""];
      return ((function() {
        var j, ref, results;
        results = [];
        for (line = j = 1, ref = lines; 1 <= ref ? j <= ref : j >= ref; line = 1 <= ref ? ++j : --j) {
          results.push((row = (function() {
            var k, ref1, results1;
            results1 = [];
            for (column = k = 0, ref1 = columns - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; column = 0 <= ref1 ? ++k : --k) {
              results1.push(turns[column % 2] + variants.sample());
            }
            return results1;
          })(), row.push("U" + (variantsForU.sample())), row.join(" ")));
        }
        return results;
      })()).join("\n");
    };

    pyraminx = function(length) {
      var axis, scramble, t, tipLength, tipTurns, turns, variants, x;
      turns = ["U", "L", "R", "B"];
      variants = ['', "'"];
      tipLength = rand(4);
      tipTurns = ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = turns.length; j < len; j++) {
          t = turns[j];
          results.push(t.toLowerCase());
        }
        return results;
      })()).shuffle().slice(0, +tipLength + 1 || 9e9);
      scramble = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = tipTurns.length; j < len; j++) {
          t = tipTurns[j];
          results.push(t + variants.sample());
        }
        return results;
      })();
      axis = rand(turns.length);
      scramble = scramble.concat((function() {
        var j, ref, ref1, results;
        results = [];
        for (x = j = ref = tipLength + 1, ref1 = length; ref <= ref1 ? j <= ref1 : j >= ref1; x = ref <= ref1 ? ++j : --j) {
          results.push((axis = (axis + rand(turns.length - 1) + 1) % turns.length, turns[axis] + variants.sample()));
        }
        return results;
      })());
      return scramble.join(" ");
    };

    clock = function(length) {
      var d, i, moves, pins, scramble, state, states, u;
      pins = ["U", "d"];
      states = ["UUdd", "dUdU", "ddUU", "UdUd", "dUUU", "UdUU", "UUUd", "UUdU", "UUUU", "dddd"];
      scramble = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = states.length; j < len; j++) {
          state = states[j];
          results.push((moves = [], u = rand(12) - 5, d = rand(12) - 5, state.replace("d", "").length > 1 ? moves.push("u=" + u) : void 0, state.replace("U", "").length > 1 ? moves.push("d=" + d) : void 0, state + " " + moves.join("; ")));
        }
        return results;
      })();
      scramble.push(((function() {
        var j, results;
        results = [];
        for (i = j = 1; j <= 4; i = ++j) {
          results.push(pins.sample());
        }
        return results;
      })()).join(""));
      return scramble.join(" / ");
    };

    square1 = function() {
      var downLayer, downMove, downMoves, i, length, s, scramble, temp, upLayer, upMove, upMoves;
      scramble = [];
      upLayer = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j <= 7; i = ++j) {
          results.push(i % 2 === 0 ? 30 : 60);
        }
        return results;
      })();
      downLayer = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j <= 7; i = ++j) {
          results.push(i % 2 === 0 ? 30 : 60);
        }
        return results;
      })();
      length = 0;
      while (length <= 40) {
        upMoves = possibleMoves(upLayer);
        downMoves = possibleMoves(downLayer);
        upMove = upMoves.sample();
        if (upMove === 0) {
          downMoves = downMoves.remove(0);
        }
        downMove = downMoves.sample();
        scramble.push([humanize_sq_one_move(upLayer, upMove), humanize_sq_one_move(downLayer, downMove) * -1]);
        upLayer = doMove(upLayer, upMove);
        downLayer = doMove(downLayer, downMove);
        length += upMove === 0 ? 0 : 1;
        length += downMove === 0 ? 0 : 1;
        temp = doSlice(upLayer, downLayer);
        upLayer = temp.up;
        downLayer = temp.down;
        length += 1;
      }
      return ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = scramble.length; j < len; j++) {
          s = scramble[j];
          results.push("(" + (s.join(', ')) + ")");
        }
        return results;
      })()).join(" / ");
    };

    possibleMoves = function(layer) {
      var e, j, len, result, start, sum;
      result = [];
      for (start = j = 0, len = layer.length; j < len; start = ++j) {
        e = layer[start];
        sum = 0;
        if (_.any(layer, function(e, i) {
          sum += layer[(start + i) % layer.length];
          return sum === 180;
        })) {
          result.push(start);
        }
      }
      return result;
    };

    doMove = function(layer, move) {
      move = move % layer.length;
      if (move === 0) {
        return layer;
      } else {
        return layer.slice(move).concat(layer.slice(0, +(move - 1) + 1 || 9e9));
      }
    };

    splitLayer = function(layer) {
      var big, e, small, sum;
      sum = 0;
      small = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = layer.length; j < len; j++) {
          e = layer[j];
          if ((sum += e, sum <= 180)) {
            results.push(e);
          }
        }
        return results;
      })();
      big = layer.slice(small.length);
      return [small, big];
    };

    doSlice = function(up, down) {
      var downSplits, upSplits;
      upSplits = splitLayer(up);
      downSplits = splitLayer(down);
      return {
        up: downSplits[0].reverse().concat(upSplits[1]),
        down: upSplits[0].reverse().concat(downSplits[1])
      };
    };

    humanize_sq_one_move = function(layer, move) {
      if (move !== 0) {
        move = _.reduce(layer.slice(0, +(move - 1) + 1 || 9e9), (function(sum, x) {
          if (x === 30) {
            return sum + 1;
          } else {
            return sum + 2;
          }
        }), 0);
      }
      if (move > 6) {
        return move - 12;
      } else {
        return move;
      }
    };

    rand = function(n) {
      return Math.floor(Math.random() * n);
    };

    return Scrambler;

  })();

}).call(this);
